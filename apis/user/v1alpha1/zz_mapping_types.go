// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MappingInitParameters struct {

	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.
	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper
	// +mapType=granular
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The name of an existing server for which the user mapping is to be created.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing server for which the user mapping is to be created
	ServerName *string `json:"serverName,omitempty" tf:"server_name,omitempty"`

	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

type MappingObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.
	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper
	// +mapType=granular
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The name of an existing server for which the user mapping is to be created.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing server for which the user mapping is to be created
	ServerName *string `json:"serverName,omitempty" tf:"server_name,omitempty"`

	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

type MappingParameters struct {

	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.
	// This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Options map[string]*string `json:"options,omitempty" tf:"options,omitempty"`

	// The name of an existing server for which the user mapping is to be created.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing server for which the user mapping is to be created
	// +kubebuilder:validation:Optional
	ServerName *string `json:"serverName,omitempty" tf:"server_name,omitempty"`

	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.
	// Changing this value
	// will force the creation of a new resource as this value can only be set
	// when the user mapping is created.
	// The name of an existing user that is mapped to foreign server. CURRENT_ROLE, CURRENT_USER, and USER match the name of the current user. When PUBLIC is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable
	// +kubebuilder:validation:Optional
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

// MappingSpec defines the desired state of Mapping
type MappingSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MappingParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MappingInitParameters `json:"initProvider,omitempty"`
}

// MappingStatus defines the observed state of Mapping.
type MappingStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MappingObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Mapping is the Schema for the Mappings API. Creates and manages a user mapping on a PostgreSQL server.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,postgresql}
type Mapping struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.serverName) || (has(self.initProvider) && has(self.initProvider.serverName))",message="spec.forProvider.serverName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.userName) || (has(self.initProvider) && has(self.initProvider.userName))",message="spec.forProvider.userName is a required parameter"
	Spec   MappingSpec   `json:"spec"`
	Status MappingStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MappingList contains a list of Mappings
type MappingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Mapping `json:"items"`
}

// Repository type metadata.
var (
	Mapping_Kind             = "Mapping"
	Mapping_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Mapping_Kind}.String()
	Mapping_KindAPIVersion   = Mapping_Kind + "." + CRDGroupVersion.String()
	Mapping_GroupVersionKind = CRDGroupVersion.WithKind(Mapping_Kind)
)

func init() {
	SchemeBuilder.Register(&Mapping{}, &MappingList{})
}
